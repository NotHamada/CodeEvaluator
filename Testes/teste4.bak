#lang racket

(require srfi/13)

(define final-grade 0)

; Função que remove espaços em branco
(define (trim-whitespace str)
  (letrec ((start-trim (lambda (s)
                         (if (and (not (string=? s "")) (char-whitespace? (string-ref s 0)))
                             (start-trim (substring s 1))
                             s)))
           (end-trim (lambda (s)
                       (if (and (not (string=? s "")) (char-whitespace? (string-ref s (- (string-length s) 1))))
                           (end-trim (substring s 0 (- (string-length s) 1)))
                           s))))
    (end-trim (start-trim str))))

; Função que verifica se uma linha está vazia
(define (is-empty-line? line)
  (string=? "" (trim-whitespace line)))

; Função que conta o número de ocorrências de um caractere específico em uma string
(define (count-char-occurrences char str)
  (define (count-helper char str count)
    (cond
      [(= (string-length str) 0) count]
      [(char=? (string-ref str 0) char) (count-helper char (substring str 1) (+ count 1))]
      [else (count-helper char (substring str 1) count)]))
  (count-helper char str 0))

; Função que conta o número de parênteses abertos
(define (count-open-parentheses line)
  (count-char-occurrences #\( line))

; Função que conta o número de parênteses fechados
(define (count-close-parentheses line)
  (count-char-occurrences #\) line))

; Função que verifica se a linha tem um comentário
(define (verify-comment line)
  (if (= 1 (count-char-occurrences #\; line)) 1 0))

; Funções para o sistema de notas

(define (table-comments)
  (displayln "Grading comments table:")
  (displayln "5: 25% - 29%")
  (displayln "4: 20% - 24% or 30% - 34%")
  (displayln "3: 15% - 19% or 35% - 39%")
  (displayln "2: 10% - 14% or 40% - 44%")
  (displayln "1:  0% -  9% or 45+%")
)

(define (table-cohesion)
  (displayln "Grading cohesion table:")
  (displayln "5: 80% - 100%")
  (displayln "4: 60% - 79%")
  (displayln "3: 40% - 59%")
  (displayln "2: 20% - 39%")
  (displayln "1:  0% - 19%")
)

(define (comments-grade comments lines)
  (define grade 0)
  (define percentage-comments (exact->inexact (* 100 (/ comments lines))))

  (newline)

  (displayln "- Comments grading -")
  (displayln "Formula for the calculation: comments / total lines of file" )
  (displayln (format "= ~a / ~a" comments lines))
  (displayln (format "= ~a" (exact->inexact (/ comments lines))))
  (displayln (format "= ~a %" percentage-comments))

  (newline)

  (table-comments)

  (cond
    [(and (>= percentage-comments 25) (< percentage-comments 30))
      (set! grade 5)]
    [(or (and (>= percentage-comments 20) (< percentage-comments 25)) (and (>= percentage-comments 30) (< percentage-comments 35)))
      (set! grade 4)]
    [(or (and (>= percentage-comments 15) (>= percentage-comments 15) (< percentage-comments 20)) (and (>= percentage-comments 35) (< percentage-comments 40)))
      (set! grade 3)]
    [(or (and (>= percentage-comments 10) (< percentage-comments 15)) (and (>= percentage-comments 40) (< percentage-comments 45)))
      (set! grade 2)]
    [else
      (set! grade 1)]
  )

  (displayln (format "Comments grade: ~a of 5" grade))
  (set! final-grade (+ final-grade grade))
)

; Função para avaliar a coesão do código
(define (cohesion-grade lst-functions average-lines)
  (define interval (ceiling average-lines)) ; Average of the sizes of functions
  (define max-value (apply max lst-functions)) ; The biggest function
  (define min-value (apply min lst-functions)) ; The smallest function
  (define limits (+ interval (/ (+ min-value max-value) 2))) ; Top limit
  
  (newline)

  ; Explanation of how we did the calculation for the grade
  (displayln "- Cohesion grading -")
  (displayln "Formula for the calculation: average lines by function + ((biggest function + smallest function) / 2)")
  (displayln "and")
  (displayln "((biggest function + smallest function) / 2) - average lines by function")
  (displayln (format "= ~a + ((~a + ~a) / 2)  " interval max-value min-value))
  (displayln (format "= ~a + ~a" interval (/ (+ max-value min-value) 2)))
  (displayln (format "= [~a; ~a]" (- limits interval) limits))

  (newline)

  ; Explaining why the percentage
  (displayln "To reach the percentages, we get the functions there are in the interval.")
  (displayln "Then we do: number of (cohesive functions / total functions) * 100")

  (newline)

  ; Iterate each one of the functions to see if they are cohesive
  (let ((cohesive-functions 0)
        (grade 0))
    (display "Function lines: ")
    (for-each
    (lambda (item)
      (display (format "~a " item)) ; Display the number of lines of the function 
      (cond
        [(and (>= item (- limits interval)) (<= item limits)) ; Conditional to see if it is cohesive
          (set! cohesive-functions (+ cohesive-functions 1))] ; Setting + 1 cohesive functions
        ))
    lst-functions)

    ; Getting the percentage
    (define percentage-cohesion (exact->inexact (* 100 (/ cohesive-functions (length lst-functions)))))

    (newline)

    ; Printing the percentage and the number of cohesive functions
    (displayln (format "Number of cohesive functions: ~a" cohesive-functions))
    (displayln (format "Percentage: ~a / ~a = ~a %" cohesive-functions (length lst-functions) percentage-cohesion))
    
    ; Conditional of cohesion
    (cond
      [(and (>= percentage-cohesion 80))
        (set! grade 5)]
      [(and (>= percentage-cohesion 60) (< percentage-cohesion 80))
        (set! grade 4)]
      [(and (>= percentage-cohesion 40) (< percentage-cohesion 60))
        (set! grade 3)]
      [(and (>= percentage-cohesion 20) (< percentage-cohesion 40))
        (set! grade 2)]
      [else (set! grade 1)]
      )

    ; Calling the table
    (table-cohesion)

    ; Printing the grade and setting the grade
    (displayln (format "Cohesion grade: ~a of 5" grade))
    (set! final-grade (+ final-grade grade))
  )
)

; Função para calcular a nota do código
(define (calculate lst)
  (define grade 0)
  (define comments (car lst))
  (define lines (car (cdr lst)))
  (define functions (car (cddr lst)))
  (define sum-function-lines (car (cdddr lst)))
  (define variables (car (cddddr lst)))
  (define lst-functions (car (cdr (cddddr lst))))
  (define average-lines (exact->inexact (/ sum-function-lines functions)))

  (displayln (format "Average lines per function: ~a" average-lines)) ; Average lines per function
  (displayln (format "Variables and calls: ~a" variables)) ; How many calls and variables
  (displayln (format "Comments: ~a" comments)) ; Number of comments
  (displayln (format "Total lines: ~a" lines)) ; Total lines of the file
  (displayln (format "Total functions: ~a" functions)) ; And the number of functions

  (comments-grade comments lines) ; Calls the comments grading system
  (cohesion-grade lst-functions average-lines) ; Calls the cohesion grading system

  (newline)

  (displayln (format "Grade: ~a / 10" final-grade)) ; Displays the final grade
)

; Função principal para identificar funções e variáveis no arquivo
(define (identify-functions-and-variables file-path)
  (define input-port (open-input-file file-path)) ; Get file

  ; Starts a iteration until the end of file, with some important variables
  (let loop ((line-number 1)
             (function-lines 0)
             (open-parentheses 0)
             (close-parentheses 0)
             (comments 0)
             (number-of-functions 0)
             (sum-function-lines 0)
             (variables 0)
             (lst-function-lines (list))
             (line (read-line input-port)))
    ; Here we have a cond 
    (cond
      [(and (eof-object? line) (< 0 close-parentheses)) ; Code with wrong syntasis is a 0 
        (displayln "Code has wrong syntasis! Final grade is 0!")
        (close-input-port input-port)
      ]
      [(and (eof-object? line) (not (eq? line (current-input-port)))) ; File ended
       (close-input-port input-port)
       (calculate (list comments line-number number-of-functions sum-function-lines variables lst-function-lines))
      ]
      [(is-empty-line? line) ; Line is empty
       (loop line-number function-lines open-parentheses close-parentheses comments number-of-functions sum-function-lines variables lst-function-lines (read-line input-port))]
      [(not (eq? line (current-input-port))) ; Line not empty, so we have another cond inside to verify some conditions 
       (let (
              (new-open-parentheses (+ open-parentheses (count-open-parentheses line)))
              (new-close-parentheses (+ close-parentheses (count-close-parentheses line)))
              (has-comments (verify-comment line))
              ) ; Variables that verify if there is parentheses, or comments
              (cond
              [(and (= new-open-parentheses new-close-parentheses) (= function-lines 0)) ; Verify if it is a call or variable
                (loop (add1 line-number) 0 0 0 (+ comments has-comments) number-of-functions sum-function-lines (add1 variables) lst-function-lines (read-line input-port)) 
              ]
              [(and (= new-open-parentheses new-close-parentheses) (< 0 new-open-parentheses) (< 0 new-close-parentheses) (< 0 function-lines)) ; Verify if a function has ended
                (loop (add1 line-number) 0 0 0 (+ comments has-comments) (add1 number-of-functions) (+ sum-function-lines (add1 function-lines)) variables (append lst-function-lines (list (add1 function-lines))) (read-line input-port))
              ]
              [(not (or (and (= new-open-parentheses new-close-parentheses) (= function-lines 0)) (and (= new-open-parentheses new-close-parentheses) (< 0 new-open-parentheses) (< 0 new-close-parentheses)))) ; Verify if it still in the function or it is a function
                (loop (add1 line-number) (+ function-lines 1) new-open-parentheses new-close-parentheses (+ comments has-comments) number-of-functions sum-function-lines variables lst-function-lines (read-line input-port))
              ]
              ))])))

; Processamento do diretório e arquivos
(define directory-path "D:/uem/semestre 6/pplf/CodeEvaluator/Testes")
(define file-list (directory-list directory-path))

(for-each
 (lambda (file)
   (set! final-grade 0)
   (displayln file)
   (define file-path (build-path directory-path file))
   (displayln file-path)
   (identify-functions-and-variables file-path)
   (newline))
 file-list)

; Testes Unitários
(module+ test
  (require rackunit)

  ; Teste para trim-whitespace
  (check-equal? (trim-whitespace "  professor  ") "professor")

  ; Teste para is-empty-line?
  (check-true (is-empty-line? ""))
  (check-true (is-empty-line? "   "))
  (check-false (is-empty-line? "not empty"))

  ; Teste para count-char-occurrences
  (check-equal? (count-char-occurrences #\a "banana") 3)
  (check-equal? (count-char-occurrences #\z "banana") 0)

  ; Teste para count-open-parentheses
  (check-equal? (count-open-parentheses "(abc (def)") 2)
  (check-equal? (count-open-parentheses "no parentheses") 0)

  ; Teste para count-close-parentheses
  (check-equal? (count-close-parentheses "(abc) def)") 1)
  (check-equal? (count-close-parentheses "no parentheses") 0)

  ; Teste para verify-comment
  (check-equal? (verify-comment "; this is a comment") 1)
  (check-equal? (verify-comment "this is not a comment") 0)

)
